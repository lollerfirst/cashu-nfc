"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignedProof = exports.getSignedProofs = exports.signP2PKsecret = exports.createP2PKsecret = void 0;
const utils_1 = require("@noble/curves/abstract/utils");
const sha256_1 = require("@noble/hashes/sha256");
const secp256k1_1 = require("@noble/curves/secp256k1");
const utils_2 = require("@noble/hashes/utils");
const NUT11_js_1 = require("../common/NUT11.js");
const createP2PKsecret = (pubkey) => {
    const newSecret = [
        'P2PK',
        {
            nonce: (0, utils_1.bytesToHex)((0, utils_2.randomBytes)(32)),
            data: pubkey
        }
    ];
    const parsed = JSON.stringify(newSecret);
    return new TextEncoder().encode(parsed);
};
exports.createP2PKsecret = createP2PKsecret;
const signP2PKsecret = (secret, privateKey) => {
    const msghash = (0, sha256_1.sha256)(new TextDecoder().decode(secret));
    const sig = secp256k1_1.schnorr.sign(msghash, privateKey);
    return sig;
};
exports.signP2PKsecret = signP2PKsecret;
const getSignedProofs = (proofs, privateKey) => {
    return proofs.map((p) => {
        try {
            const parsed = (0, NUT11_js_1.parseSecret)(p.secret);
            if (parsed[0] !== 'P2PK') {
                throw new Error('unknown secret type');
            }
            return (0, exports.getSignedProof)(p, (0, utils_1.hexToBytes)(privateKey));
        }
        catch (error) {
            return p;
        }
    });
};
exports.getSignedProofs = getSignedProofs;
const getSignedProof = (proof, privateKey) => {
    if (!proof.witness) {
        proof.witness = {
            signatures: [(0, utils_1.bytesToHex)((0, exports.signP2PKsecret)(proof.secret, privateKey))]
        };
    }
    return proof;
};
exports.getSignedProof = getSignedProof;
//# sourceMappingURL=NUT11.js.map