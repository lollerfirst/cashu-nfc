"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deriveSeedFromMnemonic = exports.generateNewMnemonic = exports.deriveBlindingFactor = exports.deriveSecret = void 0;
const bip32_1 = require("@scure/bip32");
const index_js_1 = require("../common/index.js");
const bip39_1 = require("@scure/bip39");
const english_1 = require("@scure/bip39/wordlists/english");
const STANDARD_DERIVATION_PATH = `m/129372'/0'`;
var DerivationType;
(function (DerivationType) {
    DerivationType[DerivationType["SECRET"] = 0] = "SECRET";
    DerivationType[DerivationType["BLINDING_FACTOR"] = 1] = "BLINDING_FACTOR";
})(DerivationType || (DerivationType = {}));
const deriveSecret = (seed, keysetId, counter) => {
    return derive(seed, keysetId, counter, DerivationType.SECRET);
};
exports.deriveSecret = deriveSecret;
const deriveBlindingFactor = (seed, keysetId, counter) => {
    return derive(seed, keysetId, counter, DerivationType.BLINDING_FACTOR);
};
exports.deriveBlindingFactor = deriveBlindingFactor;
const derive = (seed, keysetId, counter, secretOrBlinding) => {
    const hdkey = bip32_1.HDKey.fromMasterSeed(seed);
    const keysetIdInt = (0, index_js_1.getKeysetIdInt)(keysetId);
    const derivationPath = `${STANDARD_DERIVATION_PATH}/${keysetIdInt}'/${counter}'/${secretOrBlinding}`;
    const derived = hdkey.derive(derivationPath);
    if (derived.privateKey === null) {
        throw new Error('Could not derive private key');
    }
    return derived.privateKey;
};
const generateNewMnemonic = () => {
    const mnemonic = (0, bip39_1.generateMnemonic)(english_1.wordlist, 128);
    return mnemonic;
};
exports.generateNewMnemonic = generateNewMnemonic;
const deriveSeedFromMnemonic = (mnemonic) => {
    const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);
    return seed;
};
exports.deriveSeedFromMnemonic = deriveSeedFromMnemonic;
//# sourceMappingURL=NUT09.js.map